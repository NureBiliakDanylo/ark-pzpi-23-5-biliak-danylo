МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ




КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ








Звіт
з практичної роботи № 2 з дисципліни
Аналіз та рефакторинг коду
за темою “Методи рефакторингу коду у розробці об’єктно-орієнтованих програм мовою Java: Replace Constructor with Factory Method, Replace subclass with Fields, Split Temporary Variable”
   










Виконав:                                                                                       Перевірив:
ст. гр. ПЗПІ-23-5                                                        ст. викладач кафедри ПІ
Біляк Данило                                                                 Сокорчук Ігор Петрович












Харків 2025
________________
МЕТА
Метою даної доповіді є всебічне ознайомлення з трьома ключовими методами рефакторингу програмного коду: Replace Constructor with Factory Method, Replace Subclass with Fields та Split Temporary Variable, спираючись на фундаментальні принципи, викладені у концепції "Чистого коду".
Сьогодні розробка програмного забезпечення — це не просто написання функціонального коду, а й створення гнучкої, масштабованої та зрозумілої архітектури, яку легко підтримувати та розвивати. Саме тому питання рефакторингу має стратегічне значення. Це не формальне "прибирання" коду, а необхідна складова процесу розробки, що дозволяє боротися з технічним боргом і запобігати деградації проєктної структури.
Основна мета полягає у тому, щоб продемонструвати, що рефакторинг — це інженерна дисципліна. Дотримання чітких технік, таких як ті, що ми розглянемо, дозволяє перетворювати складний, крихкий та заплутаний код на прозорий, надійний та узгоджений. Завдяки цьому розробники витрачають менше часу на пошук помилок, легше орієнтуються в чужих модулях і можуть швидше інтегрувати нові рішення.
Отже, мета роботи полягає не лише у вивченні технічних кроків кожного методу, а й у розумінні того, як ці практики впливають на загальний процес розробки, продуктивність команди та довговічність програмного забезпечення. Вона покликана сформувати у фахівців навички писати код, який легко читати, аналізувати, тестувати та розвивати.
________________
ХІД РОБОТИ
Коли ми пишемо програмний код, головна мета – щоб він працював правильно. Але не менш важливо, щоб з часом цей код не перетворився на "спагеті", яке неможливо підтримувати. У сучасній розробці, де проєкти живуть роками, а команди змінюються, код, який важко зрозуміти, стає тягарем для бізнесу.
Рефакторинг – це процес зміни внутрішньої структури програми, що не впливає на її зовнішню поведінку. Це не виправлення помилок і не додавання нових функцій. Це дисциплінована техніка, спрямована на покращення дизайну існуючого коду. Якщо кожен пише код "як зручно саме йому", без подальшого вдосконалення, у результаті виникає хаос. Рефакторинг допомагає цього уникнути.
Переваги рефакторингу:
* Покращення читабельності. Код, який легко читати, легше зрозуміти. Це знижує поріг входження для нових розробників;
* Спрощення підтримки. Добре структурований код набагато легше змінювати та доповнювати. Зміни в одному місці не ламають логіку в десяти інших;
* Швидший пошук помилок. Коли кожен метод і клас виконує одну чітку функцію, знайти джерело проблеми стає значно простіше;
* Прискорення розробки. Хоча рефакторинг потребує часу, в довгостроковій перспективі він його економить, оскільки додавати нові функції до чистої кодової бази набагато швидше.
Далі ми розглянемо три конкретні техніки, описані в книзі Роберта Мартіна "Чистий код".
1. Заміна конструктора фабричним методом (Replace Constructor with Factory Method)
Проблема: Конструктори в об'єктно-орієнтованих мовах мають суворі обмеження. По-перше, вони завжди повинні мати назву класу. Це не дозволяє створювати конструктори з іменами, що говорять самі за себе. По-друге, вони завжди повертають об'єкт свого класу, а не, наприклад, його підкласу. Це обмежує гнучкість.
Рішення: Замість прямого виклику конструктора, ми створюємо статичний метод, який інкапсулює логіку створення об'єкта. Сам конструктор робимо приватним.
Приклад:
Уявімо, що ми створюємо клас для представлення точки на координатній площині. Ми можемо створювати точку, використовуючи декартові координати (x, y) або полярні (радіус, кут).
Поганий приклад на Java(до рефакторингу):
class Point {
    private double x;
    private double y;


    // Два конструктори з однаковою сигнатурою неможливі,
    // тому використовуємо "обхідний шлях" з прапорцем. Це погано.
    public Point(double a, double b, String coordSystem) {
        if (coordSystem.equals("cartesian")) {
            this.x = a;
            this.y = b;
        } else if (coordSystem.equals("polar")) {
            this.x = a * Math.cos(b);
            this.y = a * Math.sin(b);
        }
    }
}


// Виклик коду заплутаний
Point p1 = new Point(2, 3, "cartesian");
Point p2 = new Point(5, Math.PI / 6, "polar");
Хороший приклад на Java (після рефакторингу):
class Point {
    private double x;
    private double y;


    // 1. Конструктор стає приватним
    private Point(double x, double y) {
        this.x = x;
        this.y = y;
    }


    // 2. Створюємо фабричні методи з чіткими іменами
    public static Point newCartesianPoint(double x, double y) {
        return new Point(x, y);
    }


    public static Point newPolarPoint(double radius, double angle) {
        return new Point(radius * Math.cos(angle), radius * Math.sin(angle));
    }
}


// Виклик коду тепер очевидний і читабельний
Point p1 = Point.newCartesianPoint(2, 3);
Point p2 = Point.newPolarPoint(5, Math.PI / 6);
Цей підхід робить код самодокументованим і набагато гнучкішим.
2. Заміна підкласу полями (Replace Subclass with Fields)
Проблема: Іноді ми створюємо цілу ієрархію підкласів, єдина мета яких – повертати різні константні значення. Наприклад, класи Male і Female, що успадковуються від Person. Такі підкласи не додають нової поведінки, а лише ускладнюють систему.
Рішення: Видалити підкласи і замінити їхню функціональність одним полем у батьківському класі.
Приклад використання цього методу для системи для представлення типів крові:
Поганий приклад на Java (до рефакторингу):
abstract class BloodType {
    abstract String getCode();
}


class O extends BloodType {
    String getCode() { return "O"; }
}
class A extends BloodType {
    String getCode() { return "A"; }
}
class B extends BloodType {
    String getCode() { return "B"; }
}
class AB extends BloodType {
    String getCode() { return "AB"; }
}
Тут ми маємо 4 зайві класи, які роблять одне й те саме.
Хороший приклад на Java (після рефакторингу):
class BloodType {
    public static final BloodType O = new BloodType("O");
    public static final BloodType A = new BloodType("A");
    public static final BloodType B = new BloodType("B");
    public static final BloodType AB = new BloodType("AB");


    private static final BloodType[] _values = { O, A, B, AB };


    private final String code;


    // Конструктор приватний, щоб уникнути створення інших екземплярів
    private BloodType(String code) {
        this.code = code;
    }


    public String getCode() {
        return code;
    }
}


// Використання
String bloodCode = BloodType.A.getCode();


Ми замінили ієрархію на один клас із набором константних полів. Код став набагато простішим і ефективнішим.
3. Розділення тимчасової змінної (Split Temporary Variable)
Проблема: Використання однієї тимчасової змінної для зберігання кількох різних значень у межах одного методу. Це сильно ускладнює розуміння коду, оскільки призначення змінної постійно змінюється. Читаючи такий код, доводиться тримати в голові, яке саме значення зберігає змінна в кожному конкретному рядку.
Рішення: Для кожного нового призначення створювати нову змінну з осмисленим ім'ям. Кожна змінна повинна мати лише одну відповідальність.
Для прикладу, ось функціонал розрахунку відстані:
Поганий приклад на Java (до рефакторингу):
// У цьому коді змінна `temp` використовується двічі для абсолютно різних цілей
double temp = 2 * (_height + _width);
System.out.println("Perimeter: " + temp);
temp = _height * _width; // Повторне використання!
System.out.println("Area: " + temp);


Коли хтось буде читати цей код, він може заплутатись, що саме означає temp у кожен момент часу.
Хороший приклад на Java (після рефакторингу):
// Кожна змінна має одне чітке призначення.
// Використання `final` (або `const` в інших мовах) підкреслює,
// що змінна не буде змінюватися.
final double perimeter = 2 * (_height + _width);
System.out.println("Perimeter: " + perimeter);


final double area = _height * _width;
System.out.println("Area: " + area);


Код стає очевидним. Немає жодної двозначності щодо того, за що відповідає кожна змінна. Це також значно спрощує подальший рефакторинг, наприклад, винесення частини коду в окремий метод.
Подібно до того, як у Dart є dart format для автоматичного форматування, сучасні IDE (IntelliJ IDEA, Eclipse, VS Code) мають вбудовані інструменти для автоматизації рефакторингу. Розробник може просто виділити змінну чи клас і застосувати потрібний рефакторинг через контекстне меню. Це робить процес не тільки швидким, але й безпечним, оскільки IDE автоматично оновить усі місця використання зміненого коду.


________________


ВИСНОВКИ
На основі вищевикладених матеріалів можна зазначити, що:
* Рефакторинг – це не формальність, а ключова інженерна практика. Він дозволяє підтримувати здоров'я кодової бази та запобігати її деградації.
* Конкретні техніки вирішують типові "запахи коду". Заміна конструктора фабричним методом підвищує гнучкість, заміна підкласів полями спрощує ієрархію, а розділення змінних покращує читабельність на локальному рівні.
* Чистий код – це запорука ефективної командної роботи. Коли код зрозумілий, підтримувати його та додавати нові функції стає значно легше для всіх учасників команди.
У процесі роботи ми переконалися, що рефакторинг має прямий вплив на якість програмного продукту. Дотримання єдиних підходів до покращення коду робить його зрозумілішим, спрощує підтримку та мінімізує кількість помилок. Використання автоматизованих інструментів у сучасних IDE дозволяє застосовувати ці техніки швидко та безпечно.
Таким чином, чистий і добре структурований код – це не лише показник професіоналізму розробника, а й запорука стабільності та довговічності програмного забезпечення. Дотримання практик рефакторингу сприяє ефективній командній роботі та створює міцну основу для подальшого розвитку проекту.


        
________________


ВИКОРИСТАНІ ДЖЕРЕЛА
1. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
________________
ДОДАТОК А
Посилання на відео з презентацією: https://youtu.be/IEMbLy_7J8o
________________


ДОДАТОК Б
  

Рисунок 1 - слайд презентації №1  
Рисунок 2 - слайд презентації №2  Рисунок 3 - слайд презентації №3  Рисунок 4 - слайд презентації №4  Рисунок 5 - слайд презентації №5  Рисунок 6 - слайд презентації №6  Рисунок 7 - слайд презентації №7  Рисунок 8 - слайд презентації №8  Рисунок 9 - слайд презентації №9  Рисунок 10 - слайд презентації №10  Рисунок 11 - слайд презентації №11  Рисунок 12 - слайд презентації №12
