МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ




КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ








Звіт
з лабораторної роботи № 2 з дисципліни
Аналіз та рефакторинг коду
за темою “Програмна система для прогнозування погоди із використанням технологій IoT, веб та мобільних клієнтів”
   










Виконав:                                                                                       Перевірив:
ст. гр. ПЗПІ-23-5                                                        ст. викладач кафедри ПІ
Біляк Данило                                                                 Сокорчук Ігор Петрович












Харків 2025
________________
2 ЗАВДАННЯ
1. Розробити будову програмної системи.
2. Створити UML діаграму прецедентів для серверної частини системи.
3. Створити ER діаграму даних.
4. Розробити базу даних (БД) програмної системи.
5. Створити діаграму структури БД.
6. Розробити функції роботи з БД (ORM або CoRM тощо).
7. Розробити API (REST або GraphQL, gRPC тощо) для взаємодії серверної частини з клієнтами.
8. Створити специфікацію розробленого API.
9. Створити програмну реалізацію розробленого API та функцій роботи з БД.
10. Перевірити роботу створеного програмного коду серверної частини системи.
11. Завантажити або оновити (при потребі) створений програмний код у GitHub репозиторій для лабораторних робіт у гілку репозиторію main.
12. Створити відеозапис тривалістю 7-9 хвилин з демонстрацією перевірки (тестування) описаної у розділі 3.1 Vision & Scope функціональності серверної частини.
13. Завантажити створений відеозапис у свій канал для облікового запису студента в домені nure.ua на YouTube. При завантаженні відеозапису обовʼязково встановити у налаштуваннях для цього відео українську мову як мову відео та мову субтитрів до відео.
14. Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео на YouTube.
15. Створити звіт до лабораторної роботи.
16. Вказати у звіті посилання на створений відеозапис на YouTube
17. Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua
18. Експортувати увесь створений звіт у текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт.
3 ХІД РОБОТИ
Програмна система була реалізована як серверна частина у вигляді REST API-додатку. Для розробки використано платформу Node.js, мову JavaScript та фреймворк Express.js. Робота з даними здійснюється напряму через бібліотеку Аутентифікація IoT-сенсорів виконана за допомогою статичних API-ключів, які передаються в заголовку `x-api-key`.
Система складається з кількох основних модулів: реєстрація сенсорів та видача API-ключів, прийом та зберігання показників з сенсорів (температура, вологість, тиск), а також головний модуль, де реалізована генерація локального прогнозу погоди на основі отриманих даних. Уся взаємодія з клієнтськими додатками та IoT-пристроями відбувається через єдиний REST-інтерфейс.
ER-діаграма розроблена з урахуванням специфіки задачі. Визначено основні сутності: `sensors` (IoT-сенсори), `sensor_readings` (показники з сенсорів), `sensor_locations` (географічне розташування сенсорів) та `local_forecasts` (згенеровані прогнози). Ключові зв’язки між сутностями реалізовано через зовнішні ключі з каскадним видаленням (`ON DELETE CASCADE`), що забезпечує цілісність даних при видаленні сенсора. Один сенсор може мати багато показників та згенерованих прогнозів.
Фізична модель бази даних відображає точні назви стовпців, їх типи даних (`TEXT`, `REAL`, `INTEGER`), обмеження первинних та зовнішніх ключів, а також індекси для прискорення вибірки даних за часом та ідентифікатором сенсора. Схема є простою та оптимізованою для швидкого запису та читання часових рядів.
Діаграма прецедентів відображає основних акторів системи та їх взаємодію. Серед акторів виділено “Користувача з сенсором” (відповідає за реєстрацію нових сенсорів та передачу даних на сервер) та “Адміністратор”. Авторизований (через API-ключ) користувач може надсилати дані про вимірювання та місцезнаходження сенсора. Також, клієнтський додаток (неавторизований) може запитувати згенерований локальний прогноз для будь-якого сенсора за його ID.
Для роботи з базою даних обрано бібліотеку `sqlite3`. Вона дозволяє виконувати прямі SQL-запити без використання ORM, що є доцільним для даного проєкту з його чітко визначеною та нескладною схемою. Підключення до бази даних ініціалізується при старті додатку, створюючи єдиний об'єкт з'єднання, який використовується в усьому проєкті. Код для підключення наведено нижче:
1  const sqlite3 = require('sqlite3').verbose();
2  const path = require('path');
3
4  const dbPath = path.resolve(__dirname, '../database.db');
5  const db = new sqlite3.Database(dbPath, (err) => {
6    if (err) {
7      console.error('Error opening database', err.message);
8    } else {
9      console.log('Connected to the SQLite database.');
10   }
11 });
12
13 module.exports = db;
Прикладом створення таблиць у `db_schema.sql` є код, наведений нижче:
 1  CREATE TABLE IF NOT EXISTS sensors (
 2      id TEXT PRIMARY KEY,
 3      name TEXT,
 4      location TEXT,
 5      api_key TEXT UNIQUE NOT NULL,
 6      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
 7      last_seen_at TEXT
 8  );
 9
10  CREATE TABLE IF NOT EXISTS sensor_readings (
11      id INTEGER PRIMARY KEY AUTOINCREMENT,
12      sensor_id TEXT NOT NULL,
13      temperature REAL,
14      humidity REAL,
15      pressure REAL,
16      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
17
18      FOREIGN KEY (sensor_id) REFERENCES sensors(id) ON DELETE CASCADE
19  );
Реалізація розробленого API виконана у вигляді монолітного додатку з чітким поділом логіки на файли. Головний файл `index.js` відповідає за маршрутизацію та обробку HTTP-запитів, `database.js` – за з'єднання з БД, а `localForecast.js` інкапсулює основну бізнес-логіку. Можна виділити ключову частину реалізованого коду, функцію генерації прогнозу погоди. Ця функція використовує метод лінійної регресії для аналізу останніх показників сенсора і прогнозування майбутніх значень температури, вологості та тиску. Ось як це реалізовано:
 1  async function generateLocalForecast(sensorId, hoursAhead = 1) {
 2    const readings = await new Promise((resolve, reject) => {
 3      db.all(
 4        `SELECT * FROM sensor_readings WHERE sensor_id = ? ORDER BY created_at DESC LIMIT 10`,
 5        [sensorId],
 6        (err, rows) => {
 7          if (err) reject(err);
 8          resolve(rows.reverse());
 9        }
10      );
11    });
12
13    if (readings.length < 2) {
14      return null;
15    }
16
17    const tempRegression = calculateLinearRegression(readings, 'temperature');
18
19    const lastReadingTime = new Date(readings[readings.length - 1].created_at).getTime() / 1000;
20    const firstTimestamp = new Date(readings[0].created_at).getTime() / 1000;
21    const futureTimeX = lastReadingTime - firstTimestamp + (hoursAhead * 3600);
22
23    const predictedTemp = tempRegression.intercept + tempRegression.slope * futureTimeX;
24  }
Специфікація API створена у самому коді за допомогою JSDoc-коментарів і автоматично генерується у вигляді інтерактивної документації через Swagger UI. Всі ендпоінти (`/sensors`, `/readings`, `/local-forecasts/{sensor_id}` і т.д.) детально описані, мають приклади запитів та відповідей, схеми даних та опис механізму аутентифікації. Документація доступна за шляхом `/api-docs` і слугує технічним довідником для розробників клієнтських додатків.


________________


4 ВИСНОВКИ
В ході виконання роботи було розроблено та реалізовано програмну систему у вигляді REST API для збору даних з IoT-сенсорів та генерації локальних прогнозів погоди. Система успішно виконує поставлені задачі: забезпечує реєстрацію нових пристроїв, приймає від них дані та, на основі аналізу цих даних методом лінійної регресії, розраховує прогнозні значення температури, вологості та тиску.
Архітектура додатку є простою та модульною, що полегшує її розуміння та подальшу підтримку. Використання Node.js та Express.js дозволило швидко розробити функціональний прототип. Інтерактивна документація, згенерована за допомогою Swagger, надає зрозумілий інтерфейс для взаємодії з API.


        
________________


5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Vision and Scope: Uk-v2. Харків: Харківський національний університет радіоелектроніки, 2024. URL: https://dl.nure.ua/pluginfile.php/1138788/mod_resource/content/1/Vision_and_Scope_uk-v2.pdf
2. IEEE Std 830-1998 — IEEE Recommended Practice for Software Requirements Specifications.
3. Express.js Official Documentation: https://expressjs.com
4. Sqlite Documentation: https://www.sqlite.org
________________
6 ДОДАТОК А
Посилання на відео: https://youtu.be/q8noQJ6WoN0
________________


7 ДОДАТОК Б
Графічні матеріали
  

Рис. 1 – ER-діаграма
  

Рис. 2 – Діаграма структури бази даних
  

Рис. 3 – UML діаграма прецедентів
________________


8 ДОДАТОК В
Специфікація API
/**
 * @swagger
 * components:
 *   schemas:
 *     Sensor:
 *       type: object
 *       required:
 *         - name
 *         - location
 *       properties:
 *         id:
 *           type: string
 *           description: The auto-generated id of the sensor
 *         name:
 *           type: string
 *           description: The name of the sensor
 *         location:
 *           type: string
 *           description: The location of the sensor
 *         api_key:
 *           type: string
 *           description: The API key for the sensor
 *       example:
 *         id: d5fE_asz
 *         name: Weather Station 1
 *         location: New York
 *         api_key: 12345
 *   securitySchemes:
 *     ApiKeyAuth:
 *       type: apiKey
 *       in: header
 *       name: x-api-key
 */


/**
 * @swagger
 * tags:
 *   name: Sensors
 *   description: The sensors managing API
 */


// Endpoint to register a new sensor
/**
 * @swagger
 * /sensors:
 *   post:
 *     summary: Register a new sensor
 *     tags: [Sensors]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - location
 *             properties:
 *               name:
 *                 type: string
 *               location:
 *                 type: string
 *     responses:
 *       201:
 *         description: The sensor was successfully created
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Sensor'
 *       500:
 *         description: Some server error
 */


// Endpoint to receive sensor readings
/**
 * @swagger
 * /readings:
 *   post:
 *     summary: Record a new sensor reading
 *     tags: [Sensors]
 *     security:
 *       - ApiKeyAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - temperature
 *               - humidity
 *               - pressure
 *             properties:
 *               temperature:
 *                 type: number
 *               humidity:
 *                 type: number
 *               pressure:
 *                 type: number
 *     responses:
 *       201:
 *         description: The sensor reading was successfully recorded
 *       400:
 *         description: Missing required fields
 *       401:
 *         description: API Key is required
 *       403:
 *         description: Invalid API Key
 *       500:
 *         description: Some server error
 */


// Endpoint to store sensor location
/**
 * @swagger
 * /sensor_locations:
 *   post:
 *     summary: Record or update a sensor's location
 *     tags: [Sensors]
 *     security:
 *       - ApiKeyAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - city_name
 *               - lat
 *               - lon
 *             properties:
 *               city_name:
 *                 type: string
 *               lat:
 *                 type: number
 *               lon:
 *                 type: number
 *     responses:
 *       201:
 *         description: The sensor location was successfully recorded
 *       400:
 *         description: Missing required fields
 *       401:
 *         description: API Key is required
 *       403:
 *         description: Invalid API Key
 *       500:
 *         description: Some server error
 */


/**
 * @swagger
 * /local-forecasts/{sensor_id}:
 *   get:
 *     summary: Get a local forecast for a sensor
 *     tags: [Sensors]
 *     parameters:
 *       - in: path
 *         name: sensor_id
 *         schema:
 *           type: string
 *         required: true
 *         description: The sensor id
 *       - in: query
 *         name: hours_ahead
 *         schema:
 *           type: integer
 *         description: The number of hours ahead to forecast
 *     responses:
 *       200:
 *         description: The local forecast
 *       400:
 *         description: Invalid hours_ahead parameter
 *       404:
 *         description: Not enough data to generate a local forecast
 *       500:
 *         description: Some server error
 */
